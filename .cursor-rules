# Laravel OpenTelemetry Project - Cursor Rules

这套 Cursor rule 适用于 Laravel OpenTelemetry 项目的所有编程任务，要求工程师以高级工程师的视角，严格按照流程执行任务，确保代码改动精准、高效，且不会引入问题或不必要的复杂性。

## 核心目标

确保代码改动精准、高效，且不会引入问题或不必要的复杂性，特别关注 OpenTelemetry 性能监控和 FrankenPHP Worker 模式的特殊需求。

## 规则的五个关键步骤

### 1. 明确任务范围
- 在写代码前，先分析任务，明确目标
- 制定清晰的计划，列出需要修改的函数、模块或组件，并说明原因
- 特别关注是否涉及 OpenTelemetry 追踪、FrankenPHP Worker 模式或内存管理
- 只有在计划清晰且经过深思熟虑后，才开始写代码

### 2. 精准定位代码修改点
- 确定需要修改的具体文件和代码行
- 避免无关文件的改动，若涉及多个文件，需明确说明每个文件的改动理由
- 除非任务明确要求，否则不创建新抽象或重构代码
- 特别注意 Watcher、Hook 和 Support 类的职责边界

### 3. 最小化、隔离化的代码改动
- 只编写任务直接所需的代码
- 避免添加不必要的日志、注释、测试、待办事项或错误处理
- 不要进行"顺手"的额外修改，确保新代码不干扰现有功能
- 特别注意不要破坏 OpenTelemetry 的 span 生命周期管理

### 4. 严格检查代码
- 检查代码的正确性、是否符合任务范围，以及是否会引发副作用
- 确保代码与现有代码风格一致，防止破坏已有功能
- 评估改动是否会影响下游系统
- 特别关注内存泄漏和性能影响

### 5. 清晰交付成果
- 总结改动的具体内容和原因
- 列出所有修改的文件及其具体变更
- 说明任何假设或潜在风险，供他人审查
- 特别说明对 OpenTelemetry 追踪和 FrankenPHP Worker 模式的影响

## 核心原则

- **不即兴发挥**：严格按照任务要求执行，不随意创新
- **不过度设计**：避免复杂化，只做必要的工作
- **不偏离规则**：始终遵循这套流程，确保代码安全、可靠

## 项目特定编码规范

### PHP 代码规范
- 必须使用 `<?php` 标签开头
- 必须在每个文件开头添加 `declare(strict_types=1);`
- 使用 PSR-4 自动加载标准
- 遵循 Laravel Pint 代码风格规范

### 命名约定
- 类名使用 PascalCase：`FrankenPhpWorkerWatcher`
- 方法名使用 camelCase：`onRequestStart()`
- 常量使用 SCREAMING_SNAKE_CASE：`OTEL_RESPONSE_TRACE_HEADER_NAME`
- 配置键使用 snake_case：`response_trace_header_name`

### OpenTelemetry 特定规范
- Span 名称使用 dot.notation：`frankenphp.worker.request_start`
- 属性名使用标准前缀：`frankenphp.worker.`, `http.`, `db.`
- 敏感信息必须过滤：使用 `***` 替代敏感值
- 始终正确管理 span 生命周期：确保 `startSpan()` 后有对应的 `end()`

### FrankenPHP Worker 模式规范
- Worker 模式检测：使用标准的 `isFrankenPhpWorkerMode()` 方法
- 内存管理：关注内存增长，超过阈值时记录警告
- 状态清理：在请求间正确清理 OpenTelemetry 上下文
- 错误处理：使用 `error_log()` 记录清理错误，避免影响正常请求

### 配置管理
- 环境变量使用 `OTEL_` 前缀
- 配置文件使用 `config/otel.php`
- 支持通过环境变量覆盖默认配置
- 提供合理的默认值

### 错误处理
- 使用 try-catch 包装可能失败的 OpenTelemetry 操作
- 静默处理追踪相关错误，不影响业务逻辑
- 使用 `error_log()` 记录重要错误信息
- 避免在追踪代码中抛出异常

### 性能考虑
- 最小化追踪代码的性能开销
- 使用条件检查避免不必要的操作
- 在 worker 模式下特别注意内存使用
- 合理使用垃圾回收机制

### 测试要求
- 为新功能编写单元测试
- 使用 Orchestra Testbench 进行 Laravel 集成测试
- 测试文件放在对应的 `tests/` 目录结构中
- 确保测试覆盖错误处理路径

## 代码注释规范

- **代码注释必须使用英文**
- 类和方法使用 PHPDoc 格式注释
- 复杂逻辑添加行内注释说明
- 公共 API 必须有完整的文档注释

## 文件结构约定

```
src/
├── Console/Commands/     # Artisan 命令
├── Facades/             # Laravel Facades
├── Hooks/               # OpenTelemetry Hooks (框架级拦截)
├── Support/             # 支持类和工具
├── Traits/              # 可复用的 Traits
├── Watchers/            # 应用级监听器
└── *.php               # 核心服务类
```

## 依赖管理
- 核心依赖：OpenTelemetry PHP SDK
- Laravel 框架：支持 10.0+, 11.0+, 12.0+
- PHP 版本：最低 8.4
- 必须扩展：ext-opentelemetry

## 安全考虑
- 过滤敏感信息：Cookie, Authorization, API Key
- 使用白名单机制控制记录的 HTTP 头
- 避免在追踪数据中暴露用户隐私信息
- 正确处理跨请求的状态清理

## 向后兼容性
- 保持配置文件结构的稳定性
- 避免破坏现有的 Watcher 和 Hook 接口
- 新功能使用 Feature Flag 控制
- 遵循语义化版本管理

记住：严格遵循这些规则，确保每次代码改动都是必要的、安全的和高效的。

---

# 开发指南

## 开发理念

### 核心信念

- **渐进式进步优于大爆炸式改变** - 小而可编译、通过测试的改动
- **从现有代码学习** - 实施前先学习和规划
- **实用主义优于教条主义** - 适应项目现实
- **清晰意图优于巧妙代码** - 选择无聊但明显的方案

### 简单性意味着

- 每个函数/类单一职责
- 避免过早抽象
- 没有巧妙技巧 - 选择无聊的解决方案
- 如果需要解释，说明太复杂了

## 开发流程

### 1. 规划与分阶段

将复杂工作分解为3-5个阶段。在 `IMPLEMENTATION_PLAN.md` 中记录：

```markdown
## 阶段 N: [名称]
**目标**: [具体交付物]
**成功标准**: [可测试的结果]
**测试**: [具体测试用例]
**状态**: [未开始|进行中|完成]
```
- 随着进度更新状态
- 所有阶段完成后删除文件

### 2. 实施流程

1. **理解** - 研究代码库中的现有模式
2. **测试** - 先写测试（红色）
3. **实现** - 通过测试的最小代码（绿色）
4. **重构** - 清理代码，保持测试通过
5. **提交** - 清晰的消息，链接到计划

### 3. 遇到困难时（3次尝试后）

**关键**: 每个问题最多尝试3次，然后停止。

1. **记录失败原因**:
   - 尝试了什么
   - 具体错误信息
   - 认为失败的原因

2. **研究替代方案**:
   - 找到2-3个类似实现
   - 注意使用的不同方法

3. **质疑基础假设**:
   - 这是正确的抽象级别吗？
   - 可以分解为更小的问题吗？
   - 有更简单的方法吗？

4. **尝试不同角度**:
   - 不同的库/框架功能？
   - 不同的架构模式？
   - 移除抽象而不是添加？

## 技术标准

### 架构原则

- **组合优于继承** - 使用依赖注入
- **接口优于单例** - 支持测试和灵活性
- **显式优于隐式** - 清晰的数据流和依赖关系
- **尽可能测试驱动** - 永远不要禁用测试，修复它们

### 代码质量

- **每次提交必须**:
  - 成功编译
  - 通过所有现有测试
  - 包含新功能的测试
  - 遵循项目格式/规范

- **提交前**:
  - 运行格式化工具/检查器
  - 自我审查变更
  - 确保提交消息解释"为什么"

### 错误处理

- 快速失败，包含描述性消息
- 包含调试上下文
- 在适当级别处理错误
- 永远不要静默吞掉异常

## 决策框架

当存在多个有效方法时，基于以下因素选择：

1. **可测试性** - 我能轻松测试这个吗？
2. **可读性** - 6个月后有人能理解这个吗？
3. **一致性** - 这符合项目模式吗？
4. **简单性** - 这是最简单的可行解决方案吗？
5. **可逆性** - 以后改变有多难？

## 项目集成

### 学习代码库

- 找到3个类似功能/组件
- 识别常见模式和约定
- 尽可能使用相同的库/工具
- 遵循现有测试模式

### 工具使用

- 使用项目现有的构建系统
- 使用项目的测试框架
- 使用项目的格式化/检查设置
- 没有强烈理由不要引入新工具

## 质量门禁

### 完成定义

- [ ] 测试编写并通过
- [ ] 代码遵循项目约定
- [ ] 没有格式化/检查警告
- [ ] 提交消息清晰
- [ ] 实现符合计划
- [ ] 没有无问题编号的TODO

### 测试指导原则

- 测试行为，不是实现
- 尽可能每个测试一个断言
- 清晰的测试名称描述场景
- 使用现有测试工具/助手
- 测试应该是确定性的

## 重要提醒

**永远不要**:
- 使用 `--no-verify` 绕过提交钩子
- 禁用测试而不是修复它们
- 提交无法编译的代码
- 做假设 - 用现有代码验证

**始终要**:
- 增量提交工作代码
- 随着进度更新计划文档
- 从现有实现学习
- 3次失败尝试后停止并重新评估
